# OAuth 2.0 实战课

### 开篇词 | 为什么要学 OAuth 2.0？

### 01 | OAuth 2.0 是要通过什么方式解决什么问题？

OAuth 2.0 这种授权协议，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据。

OAuth 2.0 的核心是授权许可，更进一步说就是令牌机制。

### 02 | 授权码许可类型中，为什么一定要有授权码？

***为什么需要授权码？***

在 OAuth 2.0 的体系里面有 4 种角色，它们分别是资源拥有者、客户端、授权服务和受保护资源。

![授权码许可流程](授权码许可流程.jpg)

***授权码许可类型的通信过程***

间接通信是指获取授权码的交互，而直接通信是指通过授权码换取访问令牌的交互。

OAuth 2.0 中的 4 个角色是“两两站队”的：资源拥有者和第三方软件“站在一起”，因为第三方软件要代表资源拥有者去访问受保护资源；授权服务和受保护资源“站在一起”，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。

***一定要有浏览器吗？***

OAuth 2.0 是一个授权理念，或者说是一种授权思维。

开发者通过 wx.login(Object object) 方法获取到登录凭证 code 值，这一步的流程是在小程序内部通过调用微信提供的 SDK 实现；

通过该 code 值换取用户的 session_key 等信息，也就是官方文档的 auth.code2Session 方法，同时该方法也是被强烈建议通过开发者的后端服务来调用的。

***总结***

在 OAuth 2.0 中，访问令牌被要求有极高的安全保密性，因此我们不能让它暴露在浏览器上面，只能通过第三方软件的后端服务来获取和使用，以最大限度地保障访问令牌的安全性。正因为访问令牌的这种安全要求特性，当需要前端通信（比如在浏览器上面流转）的时候，OAuth 2.0 才又提供了一个临时的凭证：授权码。通过授权码的方式，可以让用户在授权服务上给第三方软件授权之后，还能重新回到第三方软件的操作页面上。这样，在保障安全性的情况下，提升了用户的体验。

### 03 | 授权服务：授权码和访问令牌的颁发流程是怎样的？

授权服务就是负责颁发访问令牌的服务。

***授权服务的工作过程***

授权动作的前提，是第三方软件去平台那里“备案”，也就是注册。注册完后，开放平台就会给第三方软件 app_id 和 app_secret 等信息，方便后面授权时的各种身份校验。同时，在注册的时候，第三方软件也会请求受保护资源的可访问范围。

![授权服务的工作过程](授权服务的工作过程.jpg)

**颁发授权码 code**

第一步，验证基本信息。包括对第三方软件合法性和回调地址合法性的校验。

第二步，验证权限范围（第一次）。我们需要对第三方软件传过来的 scope 参数，与第三方软件注册时申请的权限范围做比对。

第三步，生成授权请求页面。只有用户登录了才可以对第三方软件进行授权，授权服务才能够获得用户信息并最终生成 code 和 app_id（第三方软件的应用标识） + user（资源拥有者标识）之间的对应关系。

第四步，验证权限范围（第二次）。用户进行授权之后的权限，再次与第三方软件注册的权限做校验。对输入数据的请求，都尽可能做一次合法性校验。

第五步，处理授权请求，生成授权码 code。代码要验证 response_type 的值是否为 code。OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且一个授权码 code 只能被使用一次。同时，授权服务还需要将生成的授权码 code 跟已经授权的权限范围 scope 进行绑定并存储，以便后续颁发访问令牌时，我们能够通过 code 值取出授权范围并与访问令牌绑定。

第六步，重定向至第三方软件。

**颁发访问令牌 access_token**

第一步，验证第三方软件是否存在。此时，接收到的 grant_type 的类型为 authorization_code。除了要校验 app_id 外，还要校验 app_secret。

第二步，验证授权码 code 值是否合法。确认过授权码 code 值有效以后，应该立刻从存储中删除当前的 code 值，以防止第三方软件恶意使用一个失窃的授权码 code 值来请求授权服务。

第三步，生成访问令牌 access_token 值。必须符合三个原则：唯一性、不连续性、不可猜性。需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。同时，授权服务还需要将授权范围跟访问令牌 access_token 做绑定。最后，还需要为该访问令牌设置一个过期时间。

***刷新令牌***

**颁发刷新令牌**

颁发刷新令牌和颁发访问令牌是一起实现的。也就是说，第三方软件得到一个访问令牌的同时，也会得到一个刷新令牌。

刷新令牌存在的初衷是，在访问令牌失效的情况下，为了不让用户频繁手动授权，通过重新请求系统生成一个新的访问令牌。

**使用刷新令牌**

第一步，接收刷新令牌请求，验证基本信息。此时请求中的 grant_type 值为 refresh_token。需要验证第三方软件是否存在；需要同时验证刷新令牌是否存在；还需要验证刷新令牌是否属于该第三方软件。

一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌。

第二步，重新生成访问令牌。

### 04 | 在 OAuth 2.0 中，如何使用 JWT 结构化令牌？

***JWT 结构化令牌***

JWT 这种结构化体可以分为 HEADER（头部）、PAYLOAD（数据体）和 SIGNATURE（签名）三部分。经过签名之后的 JWT 的整体结构，是被句点符号分割的三段内容，结构为 header.payload.signature 。

***令牌内检***

受保护资源调用授权服务提供的检验令牌服务，这种校验令牌的方式称为令牌内检。

***JWT 是如何被使用的？***

授权服务“扔出”一个令牌，受保护资源服务“接住”这个令牌，然后自己解析令牌本身所包含的信息就可以了，不需要再去查询数据库或者请求 RPC 服务。

***为什么要使用 JWT 令牌？***

JWT 的核心思想，就是用计算代替存储，有些“时间换空间”的“味道”。

因为 JWT 令牌内部包含了重要的信息，所以在整个传输过程中被要求密文传输，这也就保障了传输过程中的安全性。

使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性。通过“自编码”的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。这符合尽可能遵循无状态架构设计的原则，也就增强了系统的可用性和伸缩性。

JWT 格式令牌的最大问题在于 “覆水难收”，也就是说，没办法在使用过程中修改令牌状态。

通常有两种做法：

将每次生成 JWT 令牌时的密钥粒度缩小到用户级别，也就是一个用户一个密钥。这样，当用户取消授权或者修改密码后，就可以让这个密钥一起修改。一般情况下，这种方案需要配套一个单独的密钥管理服务。

在不考虑用户主动取消授权的场景下，如果只考虑修改密码的情况，那么我们就可以把用户密码作为 JWT 的密钥。当然，这也是用户粒度级别的。这样一来，用户修改密码也就相当于修改了密钥。

### 05 | 如何安全、快速地接入 OAuth 2.0？

***构建第三方软件应用***

**注册信息**

研发人员提前登录到开放平台进行手动注册（app_id、app_serect、redirect_uri、申请权限等），以便后续使用这些注册的相关信息请求访问令牌。

**引导授权**

让用户为第三方软件授权，在得到授权之后，第三方软件才可以代表用户访问数据。

**使用访问令牌**

官方规范给出的使用访问令牌请求的方式有三种：

Form-Encoded Body Parameter（表单参数）

```http
POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb
```

URI Query Parameter（URI 查询参数）

```http
GET /resource?access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP/1.1
Host: server.example.com
```

Authorization Request Header Field（授权请求头部字段）

```http
GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer b1a64d5c-5e0c-4a70-9711-7af6568a61fb
```

根据 OAuth 2.0 的官方建议，系统在接入 OAuth 2.0 之前信息传递的请求载体是 JSON 格式的，建议采用 Authorization 的方式来传递令牌。

我建议你采用表单提交，也就是 POST 的方式来提交令牌。因为表单提交的方式在保证安全传输的同时，还不需要额外处理 Authorization 头部信息。

**使用刷新令牌**

一个设计良好的第三方应用，应该将 expires_in 值保存下来并定时检测；如果发现 expires_in 即将过期，则需要利用 refresh_token 去重新请求授权服务，以便获取新的、有效的访问令牌。

刷新令牌是一次性的，使用之后就会失效，但是它的有效期比访问令牌长。如果刷新令牌也过期了怎么办？在这种情况下，我们需要将刷新令牌和访问令牌都放弃，相当于回到了系统的初始状态，只能让用户重新授权了。

***构建受保护资源服务***

不同的权限对应不同的操作

不同的权限对应不同的数据

不同的用户对应不同的数据