# OAuth 2.0 实战课

### 开篇词 | 为什么要学 OAuth 2.0？

### 01 | OAuth 2.0 是要通过什么方式解决什么问题？

OAuth 2.0 这种授权协议，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据。

OAuth 2.0 的核心是授权许可，更进一步说就是令牌机制。

### 02 | 授权码许可类型中，为什么一定要有授权码？

***为什么需要授权码？***

在 OAuth 2.0 的体系里面有 4 种角色，它们分别是资源拥有者、客户端、授权服务和受保护资源。

![授权码许可流程](授权码许可流程.jpg)

***授权码许可类型的通信过程***

间接通信是指获取授权码的交互，而直接通信是指通过授权码换取访问令牌的交互。

OAuth 2.0 中的 4 个角色是“两两站队”的：资源拥有者和第三方软件“站在一起”，因为第三方软件要代表资源拥有者去访问受保护资源；授权服务和受保护资源“站在一起”，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。

***一定要有浏览器吗？***

OAuth 2.0 是一个授权理念，或者说是一种授权思维。

开发者通过 wx.login(Object object) 方法获取到登录凭证 code 值，这一步的流程是在小程序内部通过调用微信提供的 SDK 实现；

通过该 code 值换取用户的 session_key 等信息，也就是官方文档的 auth.code2Session 方法，同时该方法也是被强烈建议通过开发者的后端服务来调用的。

***总结***

在 OAuth 2.0 中，访问令牌被要求有极高的安全保密性，因此我们不能让它暴露在浏览器上面，只能通过第三方软件的后端服务来获取和使用，以最大限度地保障访问令牌的安全性。正因为访问令牌的这种安全要求特性，当需要前端通信（比如在浏览器上面流转）的时候，OAuth 2.0 才又提供了一个临时的凭证：授权码。通过授权码的方式，可以让用户在授权服务上给第三方软件授权之后，还能重新回到第三方软件的操作页面上。这样，在保障安全性的情况下，提升了用户的体验。

### 03 | 授权服务：授权码和访问令牌的颁发流程是怎样的？

授权服务就是负责颁发访问令牌的服务。

***授权服务的工作过程***

授权动作的前提，是第三方软件去平台那里“备案”，也就是注册。注册完后，开放平台就会给第三方软件 app_id 和 app_secret 等信息，方便后面授权时的各种身份校验。同时，在注册的时候，第三方软件也会请求受保护资源的可访问范围。

![授权服务的工作过程](授权服务的工作过程.jpg)

**颁发授权码 code**

第一步，验证基本信息。包括对第三方软件合法性和回调地址合法性的校验。

第二步，验证权限范围（第一次）。我们需要对第三方软件传过来的 scope 参数，与第三方软件注册时申请的权限范围做比对。

第三步，生成授权请求页面。只有用户登录了才可以对第三方软件进行授权，授权服务才能够获得用户信息并最终生成 code 和 app_id（第三方软件的应用标识） + user（资源拥有者标识）之间的对应关系。

第四步，验证权限范围（第二次）。用户进行授权之后的权限，再次与第三方软件注册的权限做校验。对输入数据的请求，都尽可能做一次合法性校验。

第五步，处理授权请求，生成授权码 code。代码要验证 response_type 的值是否为 code。OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且一个授权码 code 只能被使用一次。同时，授权服务还需要将生成的授权码 code 跟已经授权的权限范围 scope 进行绑定并存储，以便后续颁发访问令牌时，我们能够通过 code 值取出授权范围并与访问令牌绑定。

第六步，重定向至第三方软件。

**颁发访问令牌 access_token**

第一步，验证第三方软件是否存在。此时，接收到的 grant_type 的类型为 authorization_code。除了要校验 app_id 外，还要校验 app_secret。

第二步，验证授权码 code 值是否合法。确认过授权码 code 值有效以后，应该立刻从存储中删除当前的 code 值，以防止第三方软件恶意使用一个失窃的授权码 code 值来请求授权服务。

第三步，生成访问令牌 access_token 值。必须符合三个原则：唯一性、不连续性、不可猜性。需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。同时，授权服务还需要将授权范围跟访问令牌 access_token 做绑定。最后，还需要为该访问令牌设置一个过期时间。

***刷新令牌***

**颁发刷新令牌**

颁发刷新令牌和颁发访问令牌是一起实现的。也就是说，第三方软件得到一个访问令牌的同时，也会得到一个刷新令牌。

刷新令牌存在的初衷是，在访问令牌失效的情况下，为了不让用户频繁手动授权，通过重新请求系统生成一个新的访问令牌。

**使用刷新令牌**

第一步，接收刷新令牌请求，验证基本信息。此时请求中的 grant_type 值为 refresh_token。需要验证第三方软件是否存在；需要同时验证刷新令牌是否存在；还需要验证刷新令牌是否属于该第三方软件。

一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌。

第二步，重新生成访问令牌。

### 04 | 在 OAuth 2.0 中，如何使用 JWT 结构化令牌？

***JWT 结构化令牌***

JWT 这种结构化体可以分为 HEADER（头部）、PAYLOAD（数据体）和 SIGNATURE（签名）三部分。经过签名之后的 JWT 的整体结构，是被句点符号分割的三段内容，结构为 header.payload.signature 。

***令牌内检***

受保护资源调用授权服务提供的检验令牌服务，这种校验令牌的方式称为令牌内检。

***JWT 是如何被使用的？***

授权服务“扔出”一个令牌，受保护资源服务“接住”这个令牌，然后自己解析令牌本身所包含的信息就可以了，不需要再去查询数据库或者请求 RPC 服务。

***为什么要使用 JWT 令牌？***

JWT 的核心思想，就是用计算代替存储，有些“时间换空间”的“味道”。

因为 JWT 令牌内部包含了重要的信息，所以在整个传输过程中被要求密文传输，这也就保障了传输过程中的安全性。

使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性。通过“自编码”的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。这符合尽可能遵循无状态架构设计的原则，也就增强了系统的可用性和伸缩性。

JWT 格式令牌的最大问题在于 “覆水难收”，也就是说，没办法在使用过程中修改令牌状态。

通常有两种做法：

将每次生成 JWT 令牌时的密钥粒度缩小到用户级别，也就是一个用户一个密钥。这样，当用户取消授权或者修改密码后，就可以让这个密钥一起修改。一般情况下，这种方案需要配套一个单独的密钥管理服务。

在不考虑用户主动取消授权的场景下，如果只考虑修改密码的情况，那么我们就可以把用户密码作为 JWT 的密钥。当然，这也是用户粒度级别的。这样一来，用户修改密码也就相当于修改了密钥。

### 05 | 如何安全、快速地接入 OAuth 2.0？

***构建第三方软件应用***

**注册信息**

研发人员提前登录到开放平台进行手动注册（app_id、app_serect、redirect_uri、申请权限等），以便后续使用这些注册的相关信息请求访问令牌。

**引导授权**

让用户为第三方软件授权，在得到授权之后，第三方软件才可以代表用户访问数据。

**使用访问令牌**

官方规范给出的使用访问令牌请求的方式有三种：

Form-Encoded Body Parameter（表单参数）

```http
POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb
```

URI Query Parameter（URI 查询参数）

```http
GET /resource?access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP/1.1
Host: server.example.com
```

Authorization Request Header Field（授权请求头部字段）

```http
GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer b1a64d5c-5e0c-4a70-9711-7af6568a61fb
```

根据 OAuth 2.0 的官方建议，系统在接入 OAuth 2.0 之前信息传递的请求载体是 JSON 格式的，建议采用 Authorization 的方式来传递令牌。

我建议你采用表单提交，也就是 POST 的方式来提交令牌。因为表单提交的方式在保证安全传输的同时，还不需要额外处理 Authorization 头部信息。

**使用刷新令牌**

一个设计良好的第三方应用，应该将 expires_in 值保存下来并定时检测；如果发现 expires_in 即将过期，则需要利用 refresh_token 去重新请求授权服务，以便获取新的、有效的访问令牌。

刷新令牌是一次性的，使用之后就会失效，但是它的有效期比访问令牌长。如果刷新令牌也过期了怎么办？在这种情况下，我们需要将刷新令牌和访问令牌都放弃，相当于回到了系统的初始状态，只能让用户重新授权了。

***构建受保护资源服务***

不同的权限对应不同的操作

不同的权限对应不同的数据

不同的用户对应不同的数据

我们应该有一个统一的网关层来处理这样的校验，所有的请求都会经过 API GATEWAY 跳转到不同的受保护资源服务。

### 06 | 除了授权码许可类型，OAuth 2.0 还支持什么授权流程？

***资源拥有者凭据许可***

软件是官方出品的，又使用 OAuth 2.0 来保护 Web API，就可以采用资源拥有者凭据许可类型。

grant_type 的值为 password。

![资源拥有者凭据许可](资源拥有者凭据许可.jpg)

***客户端凭据许可***

“资源拥有者被塞进了第三方软件中” 或者 “第三方软件就是资源拥有者”。

在获取不属于任何第三方用户的数据时，并不需要用户参与，此时便可以使用客户端凭据许可类型。

grant_type 的值为 client_credentials。

![客户端凭据许可](客户端凭据许可.jpg)

***隐式许可***

如果第三方软件直接嵌入到了浏览器中运行（JavaScript 应用），而且没有服务端的参与，并且还想使用 OAuth 2.0 流程的话，便可以直接使用隐式许可类型了。

response_type 的值为 token。

![隐式许可](隐式许可.jpg)

***如何选择？***

![授权许可类型](授权许可类型.jpg)

### 07 | 如何在移动 App 中使用 OAuth 2.0？

***没有 Server 端的 App***

将一个“迷你”的 Web 服务器嵌入到 App 里面去，通过监听运行在 localhost 上的 Web 服务器 URI，就可以做到跟普通的 Web 应用一样的通信机制。当使用这种方式时，请求访问令牌时需要的 app_secret 就只能保存在用户本地设备上，app_secret 一旦被破解，将会造成灾难性的后果。

![PKCE 协议流程图](PKCE 协议流程图.jpg)

要生成一个随机的、长度在 43~128 字符之间的、参数为 code_verifier 的字符串验证码。

怎么生成 code_challenge 的值呢？OAuth 2.0 规范里面给出了两种方法，就是看 code_challenge_method 这个参数的值：

code_challenge_method=plain，此时 code_verifier 的值就是 code_challenge 的值；

code_challenge_method=S256，将 code_verifier 的值进行 ASCII 编码之后再进行哈希，然后再将哈希之后的值进行 BASE64-URL 编码。

第一步获取授权码 code 的时候，我们使用 code_challenge 参数：

```http
https://authorization-server.com/auth?
response_type=code&
app_id=APP_ID&
redirect_uri=REDIRECT_URI&
code_challenge=CODE_CHALLENGE&
code_challenge_method=S256
```

第二步获取访问令牌的时候，我们使用 code_verifier 参数：

```http
https://api.authorization-server.com/token?
grant_type=authorization_code&
code=AUTH_CODE_HERE&
redirect_uri=REDIRECT_URI&
app_id=APP_ID&
code_verifier=CODE_VERIFIER
```

在没有 app_secret 这层保护的前提下，即使我们的授权码 code 被截获，再加上 code_challenge 也同时被截获，那也没有办法由 code_challenge 逆推出 code_verifier 的值。而恰恰在第二步换取访问令牌的时候，授权服务需要的就是 code_verifier 的值。因此，这也就避免了访问令牌被恶意换取的安全问题（实际上是为了防止授权码被截获）。

***有 Server 端的 App***

![有 Server 端的 App](有 Server 端的 App.jpg)

### 08 | 实践 OAuth 2.0 时，使用不当可能会导致哪些安全漏洞？

***CSRF 攻击***

恶意软件让浏览器向已完成用户身份认证的网站发起请求，并执行有害的操作，就是跨站请求伪造攻击。

如何避免这种攻击呢？OAuth 2.0 中也有这样的建议，就是使用 state 参数，它是一个随机值的参数。

当 B 请求授权码的时候附带一个自己生成的 state 参数，同时授权服务也要按照规则将这个随机的 state 值跟授权码 code 一起返回给 B。这样，当 B 接收到授权码的时候，就要做一个 state 参数值的比对校验，如果相同就继续流程，否则直接拒绝后续流程。

在这样的情况下，A 要想再发起 CSRF 攻击，就必须另外构造一个 state 值，而这个 state 没那么容易被伪造。

[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的 CSRF 攻击有着如下的流程：

受害者登录 a.com，并保留了登录凭证（Cookie）。

攻击者引诱受害者访问了 b.com。

b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。

a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。

a.com 以受害者的名义执行了 act=xx。

攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。

CSRF 的特点：

攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

***XSS 攻击***

XSS 攻击的主要手段是将恶意脚本注入到请求的输入中，攻击者可以通过注入的恶意脚本来进行攻击行为。

最简单的方法就是对此类非法信息做转义过滤，比如对包含 \<script\>、\<img\>、\<a\> 等标签的信息进行转义过滤。

***水平越权***

在请求受保护资源服务数据的时候，服务端应用程序未校验这条数据是否归属于当前授权的请求用户。

发生水平越权问题的根本原因，还是开发人员的认知与意识不够。同时，在开放平台环境下，由于开放网关和数据接口提供方来自不同的业务部门，防止水平校验的逻辑处理很容易被遗漏。

***授权码失窃***

校验 app_id，并删除掉使用过的授权码及其对应的访问令牌。

***重定向 URI 被篡改***

授权服务提供方并没有对第三方软件的回调 URI 做完整性校验。

### 09 | 实战：利用 OAuth 2.0 实现一个 OpenID Connect 用户身份认证协议

***OIDC 是什么？***

OIDC = 授权协议 + 身份认证，是 OAuth 2.0 的超集。

***OIDC 和 OAuth 2.0 的角色对应关系***

OIDC 的三个主要角色：

EU（End User），代表最终用户。

RP（Relying Party），代表认证服务的依赖方，就是第三方软件。

OP（OpenID Provider），代表提供身份认证服务方。

![OAuth 2.0 和 OIDC 的角色对应关系](OAuth 2.0 和 OIDC 的角色对应关系.jpg)

***OIDC 和 OAuth 2.0 的关键区别***

![基于授权码流程的 OIDC 通信流程](基于授权码流程的 OIDC 通信流程.jpg)

唯一的区别就是多返回了一个 ID_TOKEN，我们称之为 ID 令牌。

***OIDC 中的 ID 令牌生成和解析方法***

iss，令牌的颁发者，其值就是身份认证服务（OP）的 URL。

sub，令牌的主题，其值是一个能够代表最终用户（EU）的全局唯一标识符。

aud，令牌的目标受众，其值是三方软件（RP）的 app_id。

exp，令牌的到期时间戳，所有的 ID 令牌都会有一个过期时间。

iat，颁发令牌的时间戳。

***用访问令牌获取 ID 令牌之外的信息***

通过返回的访问令牌 access_token 重新发送一次请求。

细粒度地看 OIDC 的流程就是：生成 ID 令牌 -> 创建 UserInfo 端点 -> 解析 ID 令牌 -> 记录登录状态 -> 获取 UserInfo。

用 OAuth 2.0 实现 OIDC 的最关键的方法是：在原有 OAuth 2.0 流程的基础上增加 ID 令牌和 UserInfo 端点，以保障 OIDC 中的第三方软件能够记录用户状态和获取用户详情。

***单点登录***

***总结***

OAuth 2.0 不是一个身份认证协议，请一定要记住这点。身份认证强调的是“谁的问题”，而 OAuth 2.0 强调的是授权，是“可不可以”的问题。但是，我们可以在 OAuth 2.0 的基础上，通过增加 ID 令牌来获取用户的唯一标识，从而就能够去实现一个身份认证协议。

如果有个拥有海量用户的、大流量的访问平台，来提供一套统一的登录认证服务，让其他第三方应用来对接，不就可以解决一个用户使用同一个账号来登录众多第三方 App 的问题了吗？而 OIDC，就是这样的登录认证场景的开放解决方案。

### 10 | 串讲：OAuth 2.0 的工作流程与安全问题

***OAuth 2.0 工作流程串讲***

![OAuth 2.0](OAuth 2.0.jpg)

OAuth 2.0 是一种授权协议，这种协议可以让第三方软件代表用户去执行被允许的操作。那么，第三方软件就需要向用户索取授权来获得那个令牌。

委托才是 OAuth 2.0 授权概念的根基，因为没有“委托”之意就不会有“代表”行为的发生。

***OAuth 2.0 安全问题串讲***

在使用 OAuth 2.0 的流程中，我们的 HTTP 通信要使用 HTTPS 协议来保护数据传输的安全性。

***再强调都不为过的安全意识***

只有第三方软件开发者和平台方的研发人员共同保有较高的安全意识，才能让“安全的墙”垒得越来越高，让攻击者的成本越来越高。

### 11 | 实战案例：使用 Spring Security 搭建一套基于 JWT 的 OAuth 2.0 架构

